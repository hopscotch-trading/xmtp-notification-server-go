// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: xmtpv4/message_api/misbehavior_api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// API for reporting and querying node misbehavior in decentralized XMTP

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Xmtp_Xmtpv4_MessageApi_Misbehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case unresponsiveNode // = 1
  case slowNode // = 2
  case failedRequest // = 3
  case outOfOrder // = 4
  case duplicateSequenceID // = 5
  case causalOrdering // = 6
  case invalidPayload // = 7
  case blockchainInconsistency // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .unresponsiveNode
    case 2: self = .slowNode
    case 3: self = .failedRequest
    case 4: self = .outOfOrder
    case 5: self = .duplicateSequenceID
    case 6: self = .causalOrdering
    case 7: self = .invalidPayload
    case 8: self = .blockchainInconsistency
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .unresponsiveNode: return 1
    case .slowNode: return 2
    case .failedRequest: return 3
    case .outOfOrder: return 4
    case .duplicateSequenceID: return 5
    case .causalOrdering: return 6
    case .invalidPayload: return 7
    case .blockchainInconsistency: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xmtp_Xmtpv4_MessageApi_Misbehavior] = [
    .unspecified,
    .unresponsiveNode,
    .slowNode,
    .failedRequest,
    .outOfOrder,
    .duplicateSequenceID,
    .causalOrdering,
    .invalidPayload,
    .blockchainInconsistency,
  ]

}

public struct Xmtp_Xmtpv4_MessageApi_LivenessFailure: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responseTimeNs: UInt32 = 0

  public var request: Xmtp_Xmtpv4_MessageApi_LivenessFailure.OneOf_Request? = nil

  public var subscribe: Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesRequest {
    get {
      if case .subscribe(let v)? = request {return v}
      return Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesRequest()
    }
    set {request = .subscribe(newValue)}
  }

  public var query: Xmtp_Xmtpv4_MessageApi_QueryEnvelopesRequest {
    get {
      if case .query(let v)? = request {return v}
      return Xmtp_Xmtpv4_MessageApi_QueryEnvelopesRequest()
    }
    set {request = .query(newValue)}
  }

  public var publish: Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesRequest {
    get {
      if case .publish(let v)? = request {return v}
      return Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesRequest()
    }
    set {request = .publish(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable, Sendable {
    case subscribe(Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesRequest)
    case query(Xmtp_Xmtpv4_MessageApi_QueryEnvelopesRequest)
    case publish(Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesRequest)

  }

  public init() {}
}

public struct Xmtp_Xmtpv4_MessageApi_SafetyFailure: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var envelopes: [Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xmtp_Xmtpv4_MessageApi_UnsignedMisbehaviorReport: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reporterTimeNs: UInt64 = 0

  public var misbehavingNodeID: UInt32 = 0

  public var type: Xmtp_Xmtpv4_MessageApi_Misbehavior = .unspecified

  public var failure: Xmtp_Xmtpv4_MessageApi_UnsignedMisbehaviorReport.OneOf_Failure? = nil

  public var liveness: Xmtp_Xmtpv4_MessageApi_LivenessFailure {
    get {
      if case .liveness(let v)? = failure {return v}
      return Xmtp_Xmtpv4_MessageApi_LivenessFailure()
    }
    set {failure = .liveness(newValue)}
  }

  public var safety: Xmtp_Xmtpv4_MessageApi_SafetyFailure {
    get {
      if case .safety(let v)? = failure {return v}
      return Xmtp_Xmtpv4_MessageApi_SafetyFailure()
    }
    set {failure = .safety(newValue)}
  }

  /// Nodes must verify this field is false for client-submitted reports
  public var submittedByNode: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Failure: Equatable, Sendable {
    case liveness(Xmtp_Xmtpv4_MessageApi_LivenessFailure)
    case safety(Xmtp_Xmtpv4_MessageApi_SafetyFailure)

  }

  public init() {}
}

public struct Xmtp_Xmtpv4_MessageApi_MisbehaviorReport: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server time when the report was stored. Used only for querying reports.
  /// This field is not signed.
  public var serverTimeNs: UInt64 = 0

  public var unsignedMisbehaviorReport: Data = Data()

  /// Signed by the node hosting the report
  public var signature: Xmtp_Identity_Associations_RecoverableEcdsaSignature {
    get {return _signature ?? Xmtp_Identity_Associations_RecoverableEcdsaSignature()}
    set {_signature = newValue}
  }
  /// Returns true if `signature` has been explicitly set.
  public var hasSignature: Bool {return self._signature != nil}
  /// Clears the value of `signature`. Subsequent reads from it will return its default value.
  public mutating func clearSignature() {self._signature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _signature: Xmtp_Identity_Associations_RecoverableEcdsaSignature? = nil
}

public struct Xmtp_Xmtpv4_MessageApi_SubmitMisbehaviorReportRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var report: Xmtp_Xmtpv4_MessageApi_UnsignedMisbehaviorReport {
    get {return _report ?? Xmtp_Xmtpv4_MessageApi_UnsignedMisbehaviorReport()}
    set {_report = newValue}
  }
  /// Returns true if `report` has been explicitly set.
  public var hasReport: Bool {return self._report != nil}
  /// Clears the value of `report`. Subsequent reads from it will return its default value.
  public mutating func clearReport() {self._report = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _report: Xmtp_Xmtpv4_MessageApi_UnsignedMisbehaviorReport? = nil
}

public struct Xmtp_Xmtpv4_MessageApi_SubmitMisbehaviorReportResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xmtp_Xmtpv4_MessageApi_QueryMisbehaviorReportsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var afterNs: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Xmtp_Xmtpv4_MessageApi_QueryMisbehaviorReportsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reports: [Xmtp_Xmtpv4_MessageApi_MisbehaviorReport] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xmtp.xmtpv4.message_api"

extension Xmtp_Xmtpv4_MessageApi_Misbehavior: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MISBEHAVIOR_UNSPECIFIED"),
    1: .same(proto: "MISBEHAVIOR_UNRESPONSIVE_NODE"),
    2: .same(proto: "MISBEHAVIOR_SLOW_NODE"),
    3: .same(proto: "MISBEHAVIOR_FAILED_REQUEST"),
    4: .same(proto: "MISBEHAVIOR_OUT_OF_ORDER"),
    5: .same(proto: "MISBEHAVIOR_DUPLICATE_SEQUENCE_ID"),
    6: .same(proto: "MISBEHAVIOR_CAUSAL_ORDERING"),
    7: .same(proto: "MISBEHAVIOR_INVALID_PAYLOAD"),
    8: .same(proto: "MISBEHAVIOR_BLOCKCHAIN_INCONSISTENCY"),
  ]
}

extension Xmtp_Xmtpv4_MessageApi_LivenessFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LivenessFailure"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_time_ns"),
    2: .same(proto: "subscribe"),
    3: .same(proto: "query"),
    4: .same(proto: "publish"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.responseTimeNs) }()
      case 2: try {
        var v: Xmtp_Xmtpv4_MessageApi_SubscribeEnvelopesRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .subscribe(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .subscribe(v)
        }
      }()
      case 3: try {
        var v: Xmtp_Xmtpv4_MessageApi_QueryEnvelopesRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .query(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .query(v)
        }
      }()
      case 4: try {
        var v: Xmtp_Xmtpv4_MessageApi_PublishPayerEnvelopesRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .publish(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .publish(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.responseTimeNs != 0 {
      try visitor.visitSingularUInt32Field(value: self.responseTimeNs, fieldNumber: 1)
    }
    switch self.request {
    case .subscribe?: try {
      guard case .subscribe(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .query?: try {
      guard case .query(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .publish?: try {
      guard case .publish(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_LivenessFailure, rhs: Xmtp_Xmtpv4_MessageApi_LivenessFailure) -> Bool {
    if lhs.responseTimeNs != rhs.responseTimeNs {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_SafetyFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SafetyFailure"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "envelopes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.envelopes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.envelopes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.envelopes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_SafetyFailure, rhs: Xmtp_Xmtpv4_MessageApi_SafetyFailure) -> Bool {
    if lhs.envelopes != rhs.envelopes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_UnsignedMisbehaviorReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsignedMisbehaviorReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reporter_time_ns"),
    2: .standard(proto: "misbehaving_node_id"),
    3: .same(proto: "type"),
    4: .same(proto: "liveness"),
    5: .same(proto: "safety"),
    6: .standard(proto: "submitted_by_node"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.reporterTimeNs) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.misbehavingNodeID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try {
        var v: Xmtp_Xmtpv4_MessageApi_LivenessFailure?
        var hadOneofValue = false
        if let current = self.failure {
          hadOneofValue = true
          if case .liveness(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.failure = .liveness(v)
        }
      }()
      case 5: try {
        var v: Xmtp_Xmtpv4_MessageApi_SafetyFailure?
        var hadOneofValue = false
        if let current = self.failure {
          hadOneofValue = true
          if case .safety(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.failure = .safety(v)
        }
      }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.submittedByNode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.reporterTimeNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.reporterTimeNs, fieldNumber: 1)
    }
    if self.misbehavingNodeID != 0 {
      try visitor.visitSingularUInt32Field(value: self.misbehavingNodeID, fieldNumber: 2)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    switch self.failure {
    case .liveness?: try {
      guard case .liveness(let v)? = self.failure else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .safety?: try {
      guard case .safety(let v)? = self.failure else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if self.submittedByNode != false {
      try visitor.visitSingularBoolField(value: self.submittedByNode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_UnsignedMisbehaviorReport, rhs: Xmtp_Xmtpv4_MessageApi_UnsignedMisbehaviorReport) -> Bool {
    if lhs.reporterTimeNs != rhs.reporterTimeNs {return false}
    if lhs.misbehavingNodeID != rhs.misbehavingNodeID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.failure != rhs.failure {return false}
    if lhs.submittedByNode != rhs.submittedByNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_MisbehaviorReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MisbehaviorReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_time_ns"),
    2: .standard(proto: "unsigned_misbehavior_report"),
    3: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.serverTimeNs) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.unsignedMisbehaviorReport) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.serverTimeNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.serverTimeNs, fieldNumber: 1)
    }
    if !self.unsignedMisbehaviorReport.isEmpty {
      try visitor.visitSingularBytesField(value: self.unsignedMisbehaviorReport, fieldNumber: 2)
    }
    try { if let v = self._signature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_MisbehaviorReport, rhs: Xmtp_Xmtpv4_MessageApi_MisbehaviorReport) -> Bool {
    if lhs.serverTimeNs != rhs.serverTimeNs {return false}
    if lhs.unsignedMisbehaviorReport != rhs.unsignedMisbehaviorReport {return false}
    if lhs._signature != rhs._signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_SubmitMisbehaviorReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitMisbehaviorReportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "report"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._report) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._report {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_SubmitMisbehaviorReportRequest, rhs: Xmtp_Xmtpv4_MessageApi_SubmitMisbehaviorReportRequest) -> Bool {
    if lhs._report != rhs._report {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_SubmitMisbehaviorReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubmitMisbehaviorReportResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_SubmitMisbehaviorReportResponse, rhs: Xmtp_Xmtpv4_MessageApi_SubmitMisbehaviorReportResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_QueryMisbehaviorReportsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryMisbehaviorReportsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "after_ns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.afterNs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.afterNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.afterNs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_QueryMisbehaviorReportsRequest, rhs: Xmtp_Xmtpv4_MessageApi_QueryMisbehaviorReportsRequest) -> Bool {
    if lhs.afterNs != rhs.afterNs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_MessageApi_QueryMisbehaviorReportsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryMisbehaviorReportsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reports"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.reports) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reports, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_MessageApi_QueryMisbehaviorReportsResponse, rhs: Xmtp_Xmtpv4_MessageApi_QueryMisbehaviorReportsResponse) -> Bool {
    if lhs.reports != rhs.reports {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
