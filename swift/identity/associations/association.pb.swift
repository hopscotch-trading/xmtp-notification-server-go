// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: identity/associations/association.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Payloads to be signed for identity associations

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// List of identity kinds
public enum Xmtp_Identity_Associations_IdentifierKind: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int

  /// Ethereum on old clients
  case unspecified // = 0
  case ethereum // = 1
  case passkey // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ethereum
    case 2: self = .passkey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ethereum: return 1
    case .passkey: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Xmtp_Identity_Associations_IdentifierKind] = [
    .unspecified,
    .ethereum,
    .passkey,
  ]

}

/// The identifier for a member of an XID
public struct Xmtp_Identity_Associations_MemberIdentifier: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Xmtp_Identity_Associations_MemberIdentifier.OneOf_Kind? = nil

  public var ethereumAddress: String {
    get {
      if case .ethereumAddress(let v)? = kind {return v}
      return String()
    }
    set {kind = .ethereumAddress(newValue)}
  }

  public var installationPublicKey: Data {
    get {
      if case .installationPublicKey(let v)? = kind {return v}
      return Data()
    }
    set {kind = .installationPublicKey(newValue)}
  }

  public var passkey: Xmtp_Identity_Associations_Passkey {
    get {
      if case .passkey(let v)? = kind {return v}
      return Xmtp_Identity_Associations_Passkey()
    }
    set {kind = .passkey(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable, @unchecked Sendable {
    case ethereumAddress(String)
    case installationPublicKey(Data)
    case passkey(Xmtp_Identity_Associations_Passkey)

  }

  public init() {}
}

/// Passkey identifier
public struct Xmtp_Identity_Associations_Passkey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Data = Data()

  public var relyingParty: String {
    get {return _relyingParty ?? String()}
    set {_relyingParty = newValue}
  }
  /// Returns true if `relyingParty` has been explicitly set.
  public var hasRelyingParty: Bool {return self._relyingParty != nil}
  /// Clears the value of `relyingParty`. Subsequent reads from it will return its default value.
  public mutating func clearRelyingParty() {self._relyingParty = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _relyingParty: String? = nil
}

/// single member that optionally indicates the member that added them
public struct Xmtp_Identity_Associations_Member: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: Xmtp_Identity_Associations_MemberIdentifier {
    get {return _identifier ?? Xmtp_Identity_Associations_MemberIdentifier()}
    set {_identifier = newValue}
  }
  /// Returns true if `identifier` has been explicitly set.
  public var hasIdentifier: Bool {return self._identifier != nil}
  /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
  public mutating func clearIdentifier() {self._identifier = nil}

  public var addedByEntity: Xmtp_Identity_Associations_MemberIdentifier {
    get {return _addedByEntity ?? Xmtp_Identity_Associations_MemberIdentifier()}
    set {_addedByEntity = newValue}
  }
  /// Returns true if `addedByEntity` has been explicitly set.
  public var hasAddedByEntity: Bool {return self._addedByEntity != nil}
  /// Clears the value of `addedByEntity`. Subsequent reads from it will return its default value.
  public mutating func clearAddedByEntity() {self._addedByEntity = nil}

  public var clientTimestampNs: UInt64 {
    get {return _clientTimestampNs ?? 0}
    set {_clientTimestampNs = newValue}
  }
  /// Returns true if `clientTimestampNs` has been explicitly set.
  public var hasClientTimestampNs: Bool {return self._clientTimestampNs != nil}
  /// Clears the value of `clientTimestampNs`. Subsequent reads from it will return its default value.
  public mutating func clearClientTimestampNs() {self._clientTimestampNs = nil}

  public var addedOnChainID: UInt64 {
    get {return _addedOnChainID ?? 0}
    set {_addedOnChainID = newValue}
  }
  /// Returns true if `addedOnChainID` has been explicitly set.
  public var hasAddedOnChainID: Bool {return self._addedOnChainID != nil}
  /// Clears the value of `addedOnChainID`. Subsequent reads from it will return its default value.
  public mutating func clearAddedOnChainID() {self._addedOnChainID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _identifier: Xmtp_Identity_Associations_MemberIdentifier? = nil
  fileprivate var _addedByEntity: Xmtp_Identity_Associations_MemberIdentifier? = nil
  fileprivate var _clientTimestampNs: UInt64? = nil
  fileprivate var _addedOnChainID: UInt64? = nil
}

/// The first entry of any XID log. The XID must be deterministically derivable
/// from the address and nonce.
/// The recovery address defaults to the initial associated_address unless
/// there is a subsequent ChangeRecoveryAddress in the log.
public struct Xmtp_Identity_Associations_CreateInbox: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var initialIdentifier: String = String()

  public var nonce: UInt64 = 0

  /// Must be an addressable member
  public var initialIdentifierSignature: Xmtp_Identity_Associations_Signature {
    get {return _initialIdentifierSignature ?? Xmtp_Identity_Associations_Signature()}
    set {_initialIdentifierSignature = newValue}
  }
  /// Returns true if `initialIdentifierSignature` has been explicitly set.
  public var hasInitialIdentifierSignature: Bool {return self._initialIdentifierSignature != nil}
  /// Clears the value of `initialIdentifierSignature`. Subsequent reads from it will return its default value.
  public mutating func clearInitialIdentifierSignature() {self._initialIdentifierSignature = nil}

  public var initialIdentifierKind: Xmtp_Identity_Associations_IdentifierKind = .unspecified

  /// Should be provided if identifier kind is passkey
  public var relyingParty: String {
    get {return _relyingParty ?? String()}
    set {_relyingParty = newValue}
  }
  /// Returns true if `relyingParty` has been explicitly set.
  public var hasRelyingParty: Bool {return self._relyingParty != nil}
  /// Clears the value of `relyingParty`. Subsequent reads from it will return its default value.
  public mutating func clearRelyingParty() {self._relyingParty = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _initialIdentifierSignature: Xmtp_Identity_Associations_Signature? = nil
  fileprivate var _relyingParty: String? = nil
}

/// Adds a new member for an XID - either an addressable member such as a
/// wallet, or an installation acting on behalf of an address.
/// A key-pair that has been associated with one role MUST not be permitted to be
/// associated with a different role.
public struct Xmtp_Identity_Associations_AddAssociation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newMemberIdentifier: Xmtp_Identity_Associations_MemberIdentifier {
    get {return _newMemberIdentifier ?? Xmtp_Identity_Associations_MemberIdentifier()}
    set {_newMemberIdentifier = newValue}
  }
  /// Returns true if `newMemberIdentifier` has been explicitly set.
  public var hasNewMemberIdentifier: Bool {return self._newMemberIdentifier != nil}
  /// Clears the value of `newMemberIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearNewMemberIdentifier() {self._newMemberIdentifier = nil}

  public var existingMemberSignature: Xmtp_Identity_Associations_Signature {
    get {return _existingMemberSignature ?? Xmtp_Identity_Associations_Signature()}
    set {_existingMemberSignature = newValue}
  }
  /// Returns true if `existingMemberSignature` has been explicitly set.
  public var hasExistingMemberSignature: Bool {return self._existingMemberSignature != nil}
  /// Clears the value of `existingMemberSignature`. Subsequent reads from it will return its default value.
  public mutating func clearExistingMemberSignature() {self._existingMemberSignature = nil}

  public var newMemberSignature: Xmtp_Identity_Associations_Signature {
    get {return _newMemberSignature ?? Xmtp_Identity_Associations_Signature()}
    set {_newMemberSignature = newValue}
  }
  /// Returns true if `newMemberSignature` has been explicitly set.
  public var hasNewMemberSignature: Bool {return self._newMemberSignature != nil}
  /// Clears the value of `newMemberSignature`. Subsequent reads from it will return its default value.
  public mutating func clearNewMemberSignature() {self._newMemberSignature = nil}

  /// Should be provided if identifier kind is passkey
  public var relyingParty: String {
    get {return _relyingParty ?? String()}
    set {_relyingParty = newValue}
  }
  /// Returns true if `relyingParty` has been explicitly set.
  public var hasRelyingParty: Bool {return self._relyingParty != nil}
  /// Clears the value of `relyingParty`. Subsequent reads from it will return its default value.
  public mutating func clearRelyingParty() {self._relyingParty = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _newMemberIdentifier: Xmtp_Identity_Associations_MemberIdentifier? = nil
  fileprivate var _existingMemberSignature: Xmtp_Identity_Associations_Signature? = nil
  fileprivate var _newMemberSignature: Xmtp_Identity_Associations_Signature? = nil
  fileprivate var _relyingParty: String? = nil
}

/// Revokes a member from an XID. The recovery address must sign the revocation.
public struct Xmtp_Identity_Associations_RevokeAssociation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var memberToRevoke: Xmtp_Identity_Associations_MemberIdentifier {
    get {return _memberToRevoke ?? Xmtp_Identity_Associations_MemberIdentifier()}
    set {_memberToRevoke = newValue}
  }
  /// Returns true if `memberToRevoke` has been explicitly set.
  public var hasMemberToRevoke: Bool {return self._memberToRevoke != nil}
  /// Clears the value of `memberToRevoke`. Subsequent reads from it will return its default value.
  public mutating func clearMemberToRevoke() {self._memberToRevoke = nil}

  public var recoveryIdentifierSignature: Xmtp_Identity_Associations_Signature {
    get {return _recoveryIdentifierSignature ?? Xmtp_Identity_Associations_Signature()}
    set {_recoveryIdentifierSignature = newValue}
  }
  /// Returns true if `recoveryIdentifierSignature` has been explicitly set.
  public var hasRecoveryIdentifierSignature: Bool {return self._recoveryIdentifierSignature != nil}
  /// Clears the value of `recoveryIdentifierSignature`. Subsequent reads from it will return its default value.
  public mutating func clearRecoveryIdentifierSignature() {self._recoveryIdentifierSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _memberToRevoke: Xmtp_Identity_Associations_MemberIdentifier? = nil
  fileprivate var _recoveryIdentifierSignature: Xmtp_Identity_Associations_Signature? = nil
}

/// Changes the recovery identifier for an XID. The recovery identifier is not required
/// to be a member of the XID. In addition to being able to add members, the
/// recovery identifier can also revoke members.
public struct Xmtp_Identity_Associations_ChangeRecoveryAddress: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newRecoveryIdentifier: String = String()

  public var existingRecoveryIdentifierSignature: Xmtp_Identity_Associations_Signature {
    get {return _existingRecoveryIdentifierSignature ?? Xmtp_Identity_Associations_Signature()}
    set {_existingRecoveryIdentifierSignature = newValue}
  }
  /// Returns true if `existingRecoveryIdentifierSignature` has been explicitly set.
  public var hasExistingRecoveryIdentifierSignature: Bool {return self._existingRecoveryIdentifierSignature != nil}
  /// Clears the value of `existingRecoveryIdentifierSignature`. Subsequent reads from it will return its default value.
  public mutating func clearExistingRecoveryIdentifierSignature() {self._existingRecoveryIdentifierSignature = nil}

  public var newRecoveryIdentifierKind: Xmtp_Identity_Associations_IdentifierKind = .unspecified

  /// Should be provided if identifier kind is passkey
  public var relyingParty: String {
    get {return _relyingParty ?? String()}
    set {_relyingParty = newValue}
  }
  /// Returns true if `relyingParty` has been explicitly set.
  public var hasRelyingParty: Bool {return self._relyingParty != nil}
  /// Clears the value of `relyingParty`. Subsequent reads from it will return its default value.
  public mutating func clearRelyingParty() {self._relyingParty = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _existingRecoveryIdentifierSignature: Xmtp_Identity_Associations_Signature? = nil
  fileprivate var _relyingParty: String? = nil
}

/// A single identity operation
public struct Xmtp_Identity_Associations_IdentityAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Xmtp_Identity_Associations_IdentityAction.OneOf_Kind? = nil

  public var createInbox: Xmtp_Identity_Associations_CreateInbox {
    get {
      if case .createInbox(let v)? = kind {return v}
      return Xmtp_Identity_Associations_CreateInbox()
    }
    set {kind = .createInbox(newValue)}
  }

  public var add: Xmtp_Identity_Associations_AddAssociation {
    get {
      if case .add(let v)? = kind {return v}
      return Xmtp_Identity_Associations_AddAssociation()
    }
    set {kind = .add(newValue)}
  }

  public var revoke: Xmtp_Identity_Associations_RevokeAssociation {
    get {
      if case .revoke(let v)? = kind {return v}
      return Xmtp_Identity_Associations_RevokeAssociation()
    }
    set {kind = .revoke(newValue)}
  }

  public var changeRecoveryAddress: Xmtp_Identity_Associations_ChangeRecoveryAddress {
    get {
      if case .changeRecoveryAddress(let v)? = kind {return v}
      return Xmtp_Identity_Associations_ChangeRecoveryAddress()
    }
    set {kind = .changeRecoveryAddress(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable, Sendable {
    case createInbox(Xmtp_Identity_Associations_CreateInbox)
    case add(Xmtp_Identity_Associations_AddAssociation)
    case revoke(Xmtp_Identity_Associations_RevokeAssociation)
    case changeRecoveryAddress(Xmtp_Identity_Associations_ChangeRecoveryAddress)

  }

  public init() {}
}

/// One or more identity actions that were signed together.
/// Example: [CreateXid, AddAssociation, ChangeRecoveryAddress]
/// 1. The batched signature text is created by concatenating the signature text
///    of each association together with a separator, '\n\n\n'.
/// 2. The user signs this concatenated result.
/// 3. The resulting signature is added to each association proto where relevant.
///    The same signature may be used for multiple associations in the array.
public struct Xmtp_Identity_Associations_IdentityUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actions: [Xmtp_Identity_Associations_IdentityAction] = []

  public var clientTimestampNs: UInt64 = 0

  public var inboxID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Map of members belonging to an inbox_id
public struct Xmtp_Identity_Associations_MemberMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Xmtp_Identity_Associations_MemberIdentifier {
    get {return _key ?? Xmtp_Identity_Associations_MemberIdentifier()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: Xmtp_Identity_Associations_Member {
    get {return _value ?? Xmtp_Identity_Associations_Member()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: Xmtp_Identity_Associations_MemberIdentifier? = nil
  fileprivate var _value: Xmtp_Identity_Associations_Member? = nil
}

/// A final association state resulting from multiple `IdentityUpdates`
public struct Xmtp_Identity_Associations_AssociationState: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inboxID: String = String()

  public var members: [Xmtp_Identity_Associations_MemberMap] = []

  public var recoveryIdentifier: String = String()

  public var seenSignatures: [Data] = []

  public var recoveryIdentifierKind: Xmtp_Identity_Associations_IdentifierKind = .unspecified

  /// Should be provided if identifier kind is passkey
  public var relyingParty: String {
    get {return _relyingParty ?? String()}
    set {_relyingParty = newValue}
  }
  /// Returns true if `relyingParty` has been explicitly set.
  public var hasRelyingParty: Bool {return self._relyingParty != nil}
  /// Clears the value of `relyingParty`. Subsequent reads from it will return its default value.
  public mutating func clearRelyingParty() {self._relyingParty = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _relyingParty: String? = nil
}

//// state diff between two final AssociationStates
public struct Xmtp_Identity_Associations_AssociationStateDiff: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var newMembers: [Xmtp_Identity_Associations_MemberIdentifier] = []

  public var removedMembers: [Xmtp_Identity_Associations_MemberIdentifier] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xmtp.identity.associations"

extension Xmtp_Identity_Associations_IdentifierKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IDENTIFIER_KIND_UNSPECIFIED"),
    1: .same(proto: "IDENTIFIER_KIND_ETHEREUM"),
    2: .same(proto: "IDENTIFIER_KIND_PASSKEY"),
  ]
}

extension Xmtp_Identity_Associations_MemberIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberIdentifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ethereum_address"),
    2: .standard(proto: "installation_public_key"),
    3: .same(proto: "passkey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .ethereumAddress(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.kind != nil {try decoder.handleConflictingOneOf()}
          self.kind = .installationPublicKey(v)
        }
      }()
      case 3: try {
        var v: Xmtp_Identity_Associations_Passkey?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .passkey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .passkey(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .ethereumAddress?: try {
      guard case .ethereumAddress(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .installationPublicKey?: try {
      guard case .installationPublicKey(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .passkey?: try {
      guard case .passkey(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_MemberIdentifier, rhs: Xmtp_Identity_Associations_MemberIdentifier) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_Passkey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Passkey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "relying_party"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._relyingParty) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    try { if let v = self._relyingParty {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_Passkey, rhs: Xmtp_Identity_Associations_Passkey) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._relyingParty != rhs._relyingParty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Member"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .standard(proto: "added_by_entity"),
    3: .standard(proto: "client_timestamp_ns"),
    4: .standard(proto: "added_on_chain_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._addedByEntity) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._clientTimestampNs) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._addedOnChainID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._addedByEntity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._clientTimestampNs {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._addedOnChainID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_Member, rhs: Xmtp_Identity_Associations_Member) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._addedByEntity != rhs._addedByEntity {return false}
    if lhs._clientTimestampNs != rhs._clientTimestampNs {return false}
    if lhs._addedOnChainID != rhs._addedOnChainID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_CreateInbox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInbox"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_identifier"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "initial_identifier_signature"),
    4: .standard(proto: "initial_identifier_kind"),
    5: .standard(proto: "relying_party"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.initialIdentifier) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._initialIdentifierSignature) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.initialIdentifierKind) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._relyingParty) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.initialIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.initialIdentifier, fieldNumber: 1)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 2)
    }
    try { if let v = self._initialIdentifierSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.initialIdentifierKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.initialIdentifierKind, fieldNumber: 4)
    }
    try { if let v = self._relyingParty {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_CreateInbox, rhs: Xmtp_Identity_Associations_CreateInbox) -> Bool {
    if lhs.initialIdentifier != rhs.initialIdentifier {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs._initialIdentifierSignature != rhs._initialIdentifierSignature {return false}
    if lhs.initialIdentifierKind != rhs.initialIdentifierKind {return false}
    if lhs._relyingParty != rhs._relyingParty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_AddAssociation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddAssociation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_member_identifier"),
    2: .standard(proto: "existing_member_signature"),
    3: .standard(proto: "new_member_signature"),
    4: .standard(proto: "relying_party"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._newMemberIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._existingMemberSignature) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newMemberSignature) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._relyingParty) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._newMemberIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._existingMemberSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newMemberSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._relyingParty {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_AddAssociation, rhs: Xmtp_Identity_Associations_AddAssociation) -> Bool {
    if lhs._newMemberIdentifier != rhs._newMemberIdentifier {return false}
    if lhs._existingMemberSignature != rhs._existingMemberSignature {return false}
    if lhs._newMemberSignature != rhs._newMemberSignature {return false}
    if lhs._relyingParty != rhs._relyingParty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_RevokeAssociation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeAssociation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_to_revoke"),
    2: .standard(proto: "recovery_identifier_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._memberToRevoke) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recoveryIdentifierSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberToRevoke {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._recoveryIdentifierSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_RevokeAssociation, rhs: Xmtp_Identity_Associations_RevokeAssociation) -> Bool {
    if lhs._memberToRevoke != rhs._memberToRevoke {return false}
    if lhs._recoveryIdentifierSignature != rhs._recoveryIdentifierSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_ChangeRecoveryAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChangeRecoveryAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_recovery_identifier"),
    2: .standard(proto: "existing_recovery_identifier_signature"),
    3: .standard(proto: "new_recovery_identifier_kind"),
    4: .standard(proto: "relying_party"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.newRecoveryIdentifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._existingRecoveryIdentifierSignature) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.newRecoveryIdentifierKind) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._relyingParty) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.newRecoveryIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.newRecoveryIdentifier, fieldNumber: 1)
    }
    try { if let v = self._existingRecoveryIdentifierSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.newRecoveryIdentifierKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.newRecoveryIdentifierKind, fieldNumber: 3)
    }
    try { if let v = self._relyingParty {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_ChangeRecoveryAddress, rhs: Xmtp_Identity_Associations_ChangeRecoveryAddress) -> Bool {
    if lhs.newRecoveryIdentifier != rhs.newRecoveryIdentifier {return false}
    if lhs._existingRecoveryIdentifierSignature != rhs._existingRecoveryIdentifierSignature {return false}
    if lhs.newRecoveryIdentifierKind != rhs.newRecoveryIdentifierKind {return false}
    if lhs._relyingParty != rhs._relyingParty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_IdentityAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_inbox"),
    2: .same(proto: "add"),
    3: .same(proto: "revoke"),
    4: .standard(proto: "change_recovery_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Xmtp_Identity_Associations_CreateInbox?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .createInbox(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .createInbox(v)
        }
      }()
      case 2: try {
        var v: Xmtp_Identity_Associations_AddAssociation?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .add(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .add(v)
        }
      }()
      case 3: try {
        var v: Xmtp_Identity_Associations_RevokeAssociation?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .revoke(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .revoke(v)
        }
      }()
      case 4: try {
        var v: Xmtp_Identity_Associations_ChangeRecoveryAddress?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .changeRecoveryAddress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .changeRecoveryAddress(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.kind {
    case .createInbox?: try {
      guard case .createInbox(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .add?: try {
      guard case .add(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .revoke?: try {
      guard case .revoke(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .changeRecoveryAddress?: try {
      guard case .changeRecoveryAddress(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_IdentityAction, rhs: Xmtp_Identity_Associations_IdentityAction) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_IdentityUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
    2: .standard(proto: "client_timestamp_ns"),
    3: .standard(proto: "inbox_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.clientTimestampNs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.inboxID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 1)
    }
    if self.clientTimestampNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientTimestampNs, fieldNumber: 2)
    }
    if !self.inboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.inboxID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_IdentityUpdate, rhs: Xmtp_Identity_Associations_IdentityUpdate) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.clientTimestampNs != rhs.clientTimestampNs {return false}
    if lhs.inboxID != rhs.inboxID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_MemberMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_MemberMap, rhs: Xmtp_Identity_Associations_MemberMap) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_AssociationState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssociationState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inbox_id"),
    2: .same(proto: "members"),
    3: .standard(proto: "recovery_identifier"),
    4: .standard(proto: "seen_signatures"),
    5: .standard(proto: "recovery_identifier_kind"),
    6: .standard(proto: "relying_party"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inboxID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.recoveryIdentifier) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.seenSignatures) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.recoveryIdentifierKind) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._relyingParty) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.inboxID.isEmpty {
      try visitor.visitSingularStringField(value: self.inboxID, fieldNumber: 1)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 2)
    }
    if !self.recoveryIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.recoveryIdentifier, fieldNumber: 3)
    }
    if !self.seenSignatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.seenSignatures, fieldNumber: 4)
    }
    if self.recoveryIdentifierKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.recoveryIdentifierKind, fieldNumber: 5)
    }
    try { if let v = self._relyingParty {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_AssociationState, rhs: Xmtp_Identity_Associations_AssociationState) -> Bool {
    if lhs.inboxID != rhs.inboxID {return false}
    if lhs.members != rhs.members {return false}
    if lhs.recoveryIdentifier != rhs.recoveryIdentifier {return false}
    if lhs.seenSignatures != rhs.seenSignatures {return false}
    if lhs.recoveryIdentifierKind != rhs.recoveryIdentifierKind {return false}
    if lhs._relyingParty != rhs._relyingParty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Identity_Associations_AssociationStateDiff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssociationStateDiff"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "new_members"),
    2: .standard(proto: "removed_members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.newMembers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.removedMembers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newMembers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newMembers, fieldNumber: 1)
    }
    if !self.removedMembers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.removedMembers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Identity_Associations_AssociationStateDiff, rhs: Xmtp_Identity_Associations_AssociationStateDiff) -> Bool {
    if lhs.newMembers != rhs.newMembers {return false}
    if lhs.removedMembers != rhs.removedMembers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
