// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: xmtpv4/envelopes/envelopes.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Message API for XMTP V4

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The last seen entry per originator. Originators that have not been seen are omitted.
/// Entries MUST be sorted in ascending order, so that smaller node ID's appear first.
public struct Xmtp_Xmtpv4_Envelopes_VectorClock: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nodeIDToSequenceID: Dictionary<UInt32,UInt64> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Data visible to the server that has been authenticated by the client.
public struct Xmtp_Xmtpv4_Envelopes_AuthenticatedData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetOriginator: UInt32 = 0

  public var targetTopic: Data = Data()

  public var lastSeen: Xmtp_Xmtpv4_Envelopes_VectorClock {
    get {return _lastSeen ?? Xmtp_Xmtpv4_Envelopes_VectorClock()}
    set {_lastSeen = newValue}
  }
  /// Returns true if `lastSeen` has been explicitly set.
  public var hasLastSeen: Bool {return self._lastSeen != nil}
  /// Clears the value of `lastSeen`. Subsequent reads from it will return its default value.
  public mutating func clearLastSeen() {self._lastSeen = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastSeen: Xmtp_Xmtpv4_Envelopes_VectorClock? = nil
}

public struct Xmtp_Xmtpv4_Envelopes_ClientEnvelope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var aad: Xmtp_Xmtpv4_Envelopes_AuthenticatedData {
    get {return _aad ?? Xmtp_Xmtpv4_Envelopes_AuthenticatedData()}
    set {_aad = newValue}
  }
  /// Returns true if `aad` has been explicitly set.
  public var hasAad: Bool {return self._aad != nil}
  /// Clears the value of `aad`. Subsequent reads from it will return its default value.
  public mutating func clearAad() {self._aad = nil}

  public var payload: Xmtp_Xmtpv4_Envelopes_ClientEnvelope.OneOf_Payload? = nil

  public var groupMessage: Xmtp_Mls_Api_V1_GroupMessageInput {
    get {
      if case .groupMessage(let v)? = payload {return v}
      return Xmtp_Mls_Api_V1_GroupMessageInput()
    }
    set {payload = .groupMessage(newValue)}
  }

  public var welcomeMessage: Xmtp_Mls_Api_V1_WelcomeMessageInput {
    get {
      if case .welcomeMessage(let v)? = payload {return v}
      return Xmtp_Mls_Api_V1_WelcomeMessageInput()
    }
    set {payload = .welcomeMessage(newValue)}
  }

  public var uploadKeyPackage: Xmtp_Mls_Api_V1_UploadKeyPackageRequest {
    get {
      if case .uploadKeyPackage(let v)? = payload {return v}
      return Xmtp_Mls_Api_V1_UploadKeyPackageRequest()
    }
    set {payload = .uploadKeyPackage(newValue)}
  }

  public var identityUpdate: Xmtp_Identity_Associations_IdentityUpdate {
    get {
      if case .identityUpdate(let v)? = payload {return v}
      return Xmtp_Identity_Associations_IdentityUpdate()
    }
    set {payload = .identityUpdate(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable, Sendable {
    case groupMessage(Xmtp_Mls_Api_V1_GroupMessageInput)
    case welcomeMessage(Xmtp_Mls_Api_V1_WelcomeMessageInput)
    case uploadKeyPackage(Xmtp_Mls_Api_V1_UploadKeyPackageRequest)
    case identityUpdate(Xmtp_Identity_Associations_IdentityUpdate)

  }

  public init() {}

  fileprivate var _aad: Xmtp_Xmtpv4_Envelopes_AuthenticatedData? = nil
}

/// Wraps client envelope with payer signature
public struct Xmtp_Xmtpv4_Envelopes_PayerEnvelope: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protobuf serialized
  public var unsignedClientEnvelope: Data = Data()

  public var payerSignature: Xmtp_Identity_Associations_RecoverableEcdsaSignature {
    get {return _payerSignature ?? Xmtp_Identity_Associations_RecoverableEcdsaSignature()}
    set {_payerSignature = newValue}
  }
  /// Returns true if `payerSignature` has been explicitly set.
  public var hasPayerSignature: Bool {return self._payerSignature != nil}
  /// Clears the value of `payerSignature`. Subsequent reads from it will return its default value.
  public mutating func clearPayerSignature() {self._payerSignature = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payerSignature: Xmtp_Identity_Associations_RecoverableEcdsaSignature? = nil
}

/// For blockchain envelopes, these fields are set by the smart contract
public struct Xmtp_Xmtpv4_Envelopes_UnsignedOriginatorEnvelope: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var originatorNodeID: UInt32 = 0

  public var originatorSequenceID: UInt64 = 0

  public var originatorNs: Int64 = 0

  public var payerEnvelope: Xmtp_Xmtpv4_Envelopes_PayerEnvelope {
    get {return _payerEnvelope ?? Xmtp_Xmtpv4_Envelopes_PayerEnvelope()}
    set {_payerEnvelope = newValue}
  }
  /// Returns true if `payerEnvelope` has been explicitly set.
  public var hasPayerEnvelope: Bool {return self._payerEnvelope != nil}
  /// Clears the value of `payerEnvelope`. Subsequent reads from it will return its default value.
  public mutating func clearPayerEnvelope() {self._payerEnvelope = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _payerEnvelope: Xmtp_Xmtpv4_Envelopes_PayerEnvelope? = nil
}

/// An alternative to a signature for blockchain payloads
public struct Xmtp_Xmtpv4_Envelopes_BlockchainProof: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactionHash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Signed originator envelope
public struct Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protobuf serialized
  public var unsignedOriginatorEnvelope: Data = Data()

  public var proof: Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope.OneOf_Proof? = nil

  public var originatorSignature: Xmtp_Identity_Associations_RecoverableEcdsaSignature {
    get {
      if case .originatorSignature(let v)? = proof {return v}
      return Xmtp_Identity_Associations_RecoverableEcdsaSignature()
    }
    set {proof = .originatorSignature(newValue)}
  }

  public var blockchainProof: Xmtp_Xmtpv4_Envelopes_BlockchainProof {
    get {
      if case .blockchainProof(let v)? = proof {return v}
      return Xmtp_Xmtpv4_Envelopes_BlockchainProof()
    }
    set {proof = .blockchainProof(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Proof: Equatable, Sendable {
    case originatorSignature(Xmtp_Identity_Associations_RecoverableEcdsaSignature)
    case blockchainProof(Xmtp_Xmtpv4_Envelopes_BlockchainProof)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "xmtp.xmtpv4.envelopes"

extension Xmtp_Xmtpv4_Envelopes_VectorClock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VectorClock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id_to_sequence_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufUInt64>.self, value: &self.nodeIDToSequenceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeIDToSequenceID.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt32,SwiftProtobuf.ProtobufUInt64>.self, value: self.nodeIDToSequenceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_VectorClock, rhs: Xmtp_Xmtpv4_Envelopes_VectorClock) -> Bool {
    if lhs.nodeIDToSequenceID != rhs.nodeIDToSequenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_AuthenticatedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticatedData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_originator"),
    2: .standard(proto: "target_topic"),
    3: .standard(proto: "last_seen"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.targetOriginator) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.targetTopic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastSeen) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.targetOriginator != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetOriginator, fieldNumber: 1)
    }
    if !self.targetTopic.isEmpty {
      try visitor.visitSingularBytesField(value: self.targetTopic, fieldNumber: 2)
    }
    try { if let v = self._lastSeen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_AuthenticatedData, rhs: Xmtp_Xmtpv4_Envelopes_AuthenticatedData) -> Bool {
    if lhs.targetOriginator != rhs.targetOriginator {return false}
    if lhs.targetTopic != rhs.targetTopic {return false}
    if lhs._lastSeen != rhs._lastSeen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_ClientEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientEnvelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "aad"),
    2: .standard(proto: "group_message"),
    3: .standard(proto: "welcome_message"),
    4: .standard(proto: "upload_key_package"),
    5: .standard(proto: "identity_update"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._aad) }()
      case 2: try {
        var v: Xmtp_Mls_Api_V1_GroupMessageInput?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .groupMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .groupMessage(v)
        }
      }()
      case 3: try {
        var v: Xmtp_Mls_Api_V1_WelcomeMessageInput?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .welcomeMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .welcomeMessage(v)
        }
      }()
      case 4: try {
        var v: Xmtp_Mls_Api_V1_UploadKeyPackageRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .uploadKeyPackage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .uploadKeyPackage(v)
        }
      }()
      case 5: try {
        var v: Xmtp_Identity_Associations_IdentityUpdate?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .identityUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .identityUpdate(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._aad {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.payload {
    case .groupMessage?: try {
      guard case .groupMessage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .welcomeMessage?: try {
      guard case .welcomeMessage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .uploadKeyPackage?: try {
      guard case .uploadKeyPackage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .identityUpdate?: try {
      guard case .identityUpdate(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_ClientEnvelope, rhs: Xmtp_Xmtpv4_Envelopes_ClientEnvelope) -> Bool {
    if lhs._aad != rhs._aad {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_PayerEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PayerEnvelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unsigned_client_envelope"),
    2: .standard(proto: "payer_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.unsignedClientEnvelope) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._payerSignature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.unsignedClientEnvelope.isEmpty {
      try visitor.visitSingularBytesField(value: self.unsignedClientEnvelope, fieldNumber: 1)
    }
    try { if let v = self._payerSignature {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_PayerEnvelope, rhs: Xmtp_Xmtpv4_Envelopes_PayerEnvelope) -> Bool {
    if lhs.unsignedClientEnvelope != rhs.unsignedClientEnvelope {return false}
    if lhs._payerSignature != rhs._payerSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_UnsignedOriginatorEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnsignedOriginatorEnvelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "originator_node_id"),
    2: .standard(proto: "originator_sequence_id"),
    3: .standard(proto: "originator_ns"),
    4: .standard(proto: "payer_envelope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.originatorNodeID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.originatorSequenceID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.originatorNs) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._payerEnvelope) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.originatorNodeID != 0 {
      try visitor.visitSingularUInt32Field(value: self.originatorNodeID, fieldNumber: 1)
    }
    if self.originatorSequenceID != 0 {
      try visitor.visitSingularUInt64Field(value: self.originatorSequenceID, fieldNumber: 2)
    }
    if self.originatorNs != 0 {
      try visitor.visitSingularInt64Field(value: self.originatorNs, fieldNumber: 3)
    }
    try { if let v = self._payerEnvelope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_UnsignedOriginatorEnvelope, rhs: Xmtp_Xmtpv4_Envelopes_UnsignedOriginatorEnvelope) -> Bool {
    if lhs.originatorNodeID != rhs.originatorNodeID {return false}
    if lhs.originatorSequenceID != rhs.originatorSequenceID {return false}
    if lhs.originatorNs != rhs.originatorNs {return false}
    if lhs._payerEnvelope != rhs._payerEnvelope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_BlockchainProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockchainProof"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.transactionHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.transactionHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_BlockchainProof, rhs: Xmtp_Xmtpv4_Envelopes_BlockchainProof) -> Bool {
    if lhs.transactionHash != rhs.transactionHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OriginatorEnvelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unsigned_originator_envelope"),
    2: .standard(proto: "originator_signature"),
    3: .standard(proto: "blockchain_proof"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.unsignedOriginatorEnvelope) }()
      case 2: try {
        var v: Xmtp_Identity_Associations_RecoverableEcdsaSignature?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .originatorSignature(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .originatorSignature(v)
        }
      }()
      case 3: try {
        var v: Xmtp_Xmtpv4_Envelopes_BlockchainProof?
        var hadOneofValue = false
        if let current = self.proof {
          hadOneofValue = true
          if case .blockchainProof(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.proof = .blockchainProof(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.unsignedOriginatorEnvelope.isEmpty {
      try visitor.visitSingularBytesField(value: self.unsignedOriginatorEnvelope, fieldNumber: 1)
    }
    switch self.proof {
    case .originatorSignature?: try {
      guard case .originatorSignature(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .blockchainProof?: try {
      guard case .blockchainProof(let v)? = self.proof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope, rhs: Xmtp_Xmtpv4_Envelopes_OriginatorEnvelope) -> Bool {
    if lhs.unsignedOriginatorEnvelope != rhs.unsignedOriginatorEnvelope {return false}
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
